"""
API Views para o Sistema Guardi√£o
Integra√ß√£o entre Django e Bot Discord
"""
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.views import View
from django.http import JsonResponse
import json
import requests
import os
from .models import Guardian, Report, Vote, Message, Appeal, VotingSession, SessionGuardian, ReportQueue
from .serializers import ReportSerializer, VoteSerializer, GuardianSerializer


@api_view(['POST'])
@permission_classes([AllowAny])
def create_report(request):
    """
    Endpoint para o bot criar uma nova den√∫ncia
    """
    try:
        data = request.data
        
        # Validar dados obrigat√≥rios
        required_fields = ['guild_id', 'channel_id', 'reported_user_id', 'reporter_user_id']
        for field in required_fields:
            if field not in data:
                return Response(
                    {'error': f'Campo obrigat√≥rio ausente: {field}'},
                    status=status.HTTP_400_BAD_REQUEST
                )
        
        # Criar den√∫ncia
        report = Report.objects.create(
            guild_id=data['guild_id'],
            channel_id=data['channel_id'],
            reported_user_id=data['reported_user_id'],
            reporter_user_id=data['reporter_user_id'],
            reason=data.get('reason', ''),
            status='pending'
        )
        
        # Criar mensagens se fornecidas
        if 'messages' in data:
            for msg_data in data['messages']:
                Message.objects.create(
                    report=report,
                    original_user_id=msg_data['original_user_id'],
                    original_message_id=msg_data['original_message_id'],
                    anonymized_username=msg_data['anonymized_username'],
                    content=msg_data['content'],
                    timestamp=msg_data['timestamp'],
                    is_reported_user=msg_data.get('is_reported_user', False)
                )
        
        # Notificar Guardi√µes online
        notify_guardians(report)
        
        return Response({
            'success': True,
            'report_id': report.id,
            'message': 'Den√∫ncia criada com sucesso'
        }, status=status.HTTP_201_CREATED)
        
    except Exception as e:
        return Response(
            {'error': f'Erro ao criar den√∫ncia: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['POST'])
@permission_classes([AllowAny])
def apply_punishment(request):
    """
    Endpoint para o bot aplicar puni√ß√µes
    """
    try:
        data = request.data
        report_id = data.get('report_id')
        
        if not report_id:
            return Response(
                {'error': 'report_id √© obrigat√≥rio'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            report = Report.objects.get(id=report_id)
        except Report.DoesNotExist:
            return Response(
                {'error': 'Den√∫ncia n√£o encontrada'},
                status=status.HTTP_404_NOT_FOUND
            )
        
        # Enviar comando para o bot aplicar puni√ß√£o
        bot_url = os.getenv('BOT_API_URL', 'http://localhost:8081')
        bot_response = requests.post(f'{bot_url}/apply_punishment/', json={
            'report_id': report_id,
            'punishment': report.punishment,
            'user_id': report.reported_user_id,
            'guild_id': report.guild_id
        })
        
        if bot_response.status_code == 200:
            return Response({
                'success': True,
                'message': 'Puni√ß√£o aplicada com sucesso'
            })
        else:
            return Response(
                {'error': 'Erro ao aplicar puni√ß√£o no bot'},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
        
    except Exception as e:
        return Response(
            {'error': f'Erro ao processar puni√ß√£o: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['GET'])
@permission_classes([AllowAny])
def get_online_guardians(request):
    """
    Endpoint para obter lista de Guardi√µes online
    """
    try:
        guardians = Guardian.objects.filter(status='online')
        serializer = GuardianSerializer(guardians, many=True)
        
        return Response({
            'success': True,
            'guardians': serializer.data,
            'count': guardians.count()
        })
        
    except Exception as e:
        return Response(
            {'error': f'Erro ao obter Guardi√µes: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['POST'])
@permission_classes([AllowAny])
def cast_vote(request):
    """
    Endpoint para registrar um voto
    """
    try:
        data = request.data
        
        # Validar dados
        required_fields = ['report_id', 'guardian_id', 'vote_type']
        for field in required_fields:
            if field not in data:
                return Response(
                    {'error': f'Campo obrigat√≥rio ausente: {field}'},
                    status=status.HTTP_400_BAD_REQUEST
                )
        
        # Verificar se o voto √© v√°lido
        if data['vote_type'] not in ['improcedente', 'intimidou', 'grave']:
            return Response(
                {'error': 'Tipo de voto inv√°lido'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Verificar se a den√∫ncia existe
        try:
            report = Report.objects.get(id=data['report_id'])
        except Report.DoesNotExist:
            return Response(
                {'error': 'Den√∫ncia n√£o encontrada'},
                status=status.HTTP_404_NOT_FOUND
            )
        
        # Verificar se o Guardi√£o existe
        try:
            guardian = Guardian.objects.get(id=data['guardian_id'])
        except Guardian.DoesNotExist:
            return Response(
                {'error': 'Guardi√£o n√£o encontrado'},
                status=status.HTTP_404_NOT_FOUND
            )
        
        # Verificar se j√° votou
        if Vote.objects.filter(report=report, guardian=guardian).exists():
            return Response(
                {'error': 'Guardi√£o j√° votou nesta den√∫ncia'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Criar voto
        vote = Vote.objects.create(
            report=report,
            guardian=guardian,
            vote_type=data['vote_type']
        )
        
        # Atualizar contadores
        if data['vote_type'] == 'improcedente':
            report.votes_improcedente += 1
        elif data['vote_type'] == 'intimidou':
            report.votes_intimidou += 1
        elif data['vote_type'] == 'grave':
            report.votes_grave += 1
        
        report.total_votes += 1
        report.status = 'voting'
        report.save()
        
        # Verificar se a den√∫ncia foi conclu√≠da
        if report.total_votes >= 5:
            report.status = 'completed'
            report.punishment = report.calculate_punishment()
            report.save()
            
            # Notificar bot para aplicar puni√ß√£o
            notify_bot_apply_punishment(report)
        
        return Response({
            'success': True,
            'vote_id': vote.id,
            'message': 'Voto registrado com sucesso',
            'report_completed': report.total_votes >= 5
        })
        
    except Exception as e:
        return Response(
            {'error': f'Erro ao registrar voto: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['GET'])
@permission_classes([AllowAny])
def get_report_details(request, report_id):
    """
    Endpoint para obter detalhes de uma den√∫ncia
    """
    try:
        report = Report.objects.get(id=report_id)
        serializer = ReportSerializer(report)
        
        return Response({
            'success': True,
            'report': serializer.data
        })
        
    except Report.DoesNotExist:
        return Response(
            {'error': 'Den√∫ncia n√£o encontrada'},
            status=status.HTTP_404_NOT_FOUND
        )
    except Exception as e:
        return Response(
            {'error': f'Erro ao obter den√∫ncia: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['POST'])
@permission_classes([AllowAny])
@csrf_exempt
def update_guardian_status(request):
    """
    Endpoint para atualizar status do Guardi√£o
    """
    try:
        print("‚úÖ API NOVA CHAMADA: /api/guardians/status/")
        
        data = request.data
        new_status = data.get('status')
        print(f"üîÑ Status solicitado: {new_status}")
        
        if not new_status:
            print("‚ùå Status √© obrigat√≥rio")
            return Response(
                {'error': 'status √© obrigat√≥rio'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if new_status not in ['online', 'offline']:
            print("‚ùå Status inv√°lido")
            return Response(
                {'error': 'Status inv√°lido'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Obter discord_id da sess√£o
        guardian_discord_id = request.session.get('guardian_id')
        print(f"üîç Discord ID da sess√£o: {guardian_discord_id}")
        
        if not guardian_discord_id:
            print("‚ùå Usu√°rio n√£o logado")
            return Response(
                {'error': 'Usu√°rio n√£o logado'},
                status=status.HTTP_401_UNAUTHORIZED
            )
        
        try:
            guardian = Guardian.objects.get(discord_id=guardian_discord_id)
            print(f"‚úÖ Guardi√£o encontrado: {guardian.discord_display_name} (ID: {guardian.discord_id})")
        except Guardian.DoesNotExist:
            print("‚ùå Guardi√£o n√£o encontrado")
            return Response(
                {'error': 'Guardi√£o n√£o encontrado'},
                status=status.HTTP_404_NOT_FOUND
            )
        
        old_status = guardian.status
        guardian.status = new_status
        guardian.save()
        print(f"‚úÖ Status alterado de {old_status} para {new_status}")
        print(f"üîç Verificando status ap√≥s save: {guardian.status}")
        
        status_display = 'Em Servi√ßo' if new_status == 'online' else 'Fora de Servi√ßo'
        
        return Response({
            'success': True,
            'message': f'Status alterado de {old_status} para {new_status}',
            'status': new_status,
            'status_display': status_display,
            'guardian': GuardianSerializer(guardian).data
        })
        
    except Exception as e:
        print(f"‚ùå Erro: {e}")
        return Response(
            {'error': f'Erro ao atualizar status: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['GET'])
@permission_classes([AllowAny])
def get_dashboard_stats(request):
    """
    Endpoint para obter estat√≠sticas do dashboard
    """
    try:
        stats = {
            'total_reports': Report.objects.count(),
            'total_guardians': Guardian.objects.count(),
            'online_guardians': Guardian.objects.filter(status='online').count(),
            'pending_reports': Report.objects.filter(status='pending').count(),
            'voting_reports': Report.objects.filter(status='voting').count(),
            'completed_reports': Report.objects.filter(status='completed').count(),
        }
        
        return Response({
            'success': True,
            'stats': stats
        })
        
    except Exception as e:
        return Response(
            {'error': f'Erro ao obter estat√≠sticas: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['GET'])
@permission_classes([AllowAny])
def check_session(request):
    """
    Endpoint para verificar se o usu√°rio est√° logado
    """
    try:
        # Verificar se h√° sess√£o ativa
        guardian_id = request.session.get('guardian_id')
        guardian_db_id = request.session.get('guardian_db_id')
        
        print(f"üîç check_session - guardian_id: {guardian_id}, guardian_db_id: {guardian_db_id}")
        
        if guardian_id and guardian_db_id:
            print(f"‚úÖ Sess√£o v√°lida - retornando guardian_id: {guardian_id}")
            response_data = {
                'authenticated': True,
                'guardian_id': str(guardian_id),  # CORRE√á√ÉO: Converter para string
                'guardian_db_id': guardian_db_id
            }
            print(f"üîç Dados sendo retornados: {response_data}")
            return Response(response_data)
        else:
            print(f"‚ùå Sess√£o inv√°lida - guardian_id: {guardian_id}, guardian_db_id: {guardian_db_id}")
            return Response({
                'authenticated': False,
                'message': 'Usu√°rio n√£o logado'
            })
            
    except Exception as e:
        return Response(
            {'authenticated': False, 'error': str(e)},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['GET'])
@permission_classes([AllowAny])
def check_new_reports(request):
    """
    Endpoint para verificar novas den√∫ncias (para notifica√ß√µes em tempo real)
    """
    try:
        from datetime import datetime
        
        # Obter timestamp da √∫ltima verifica√ß√£o
        last_check = request.GET.get('last_check')
        
        if last_check:
            try:
                from django.utils import timezone
                # Converter para timezone-aware datetime
                last_check_dt = datetime.fromisoformat(last_check.replace('Z', '+00:00'))
                if last_check_dt.tzinfo is None:
                    last_check_dt = timezone.make_aware(last_check_dt)
                
                new_reports = Report.objects.filter(
                    created_at__gt=last_check_dt,
                    status='pending'
                ).order_by('-created_at')
            except ValueError:
                # Se timestamp inv√°lido, retornar todas as den√∫ncias pendentes
                new_reports = Report.objects.filter(status='pending').order_by('-created_at')
        else:
            # Primeira verifica√ß√£o - retornar todas as den√∫ncias pendentes
            new_reports = Report.objects.filter(status='pending').order_by('-created_at')
        
        reports_data = []
        for report in new_reports:
            reports_data.append({
                'id': report.id,
                'reason': report.reason,
                'created_at': report.created_at.isoformat(),
                'reported_user_id': report.reported_user_id,
                'reporter_user_id': report.reporter_user_id,
                'guild_id': report.guild_id,
                'channel_id': report.channel_id,
            })
        
        from django.utils import timezone
        
        return Response({
            'success': True,
            'new_reports': reports_data,
            'count': len(reports_data),
            'timestamp': timezone.now().isoformat()
        })
        
    except Exception as e:
        return Response(
            {'error': f'Erro ao verificar novas den√∫ncias: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


# Fun√ß√µes auxiliares
def notify_guardians(report):
    """
    Notifica Guardi√µes online sobre nova den√∫ncia
    """
    try:
        online_guardians = Guardian.objects.filter(status='online')
        
        # Aqui seria enviada uma notifica√ß√£o para o bot Discord
        # para que ele envie DMs para os Guardi√µes
        bot_url = os.getenv('BOT_API_URL', 'http://localhost:8081')
        requests.post(f'{bot_url}/notify_guardians/', json={
            'report_id': report.id,
            'guardian_ids': list(online_guardians.values_list('discord_id', flat=True))
        })
        
    except Exception as e:
        print(f"Erro ao notificar Guardi√µes: {e}")


def notify_bot_apply_punishment(report):
    """
    Notifica o bot para aplicar puni√ß√£o
    """
    try:
        bot_url = os.getenv('BOT_API_URL', 'http://localhost:8081')
        requests.post(f'{bot_url}/apply_punishment/', json={
            'report_id': report.id,
            'punishment': report.punishment,
            'user_id': report.reported_user_id,
            'guild_id': report.guild_id
        })
        
    except Exception as e:
        print(f"Erro ao notificar bot sobre puni√ß√£o: {e}")


# ===== NOVOS ENDPOINTS PARA SISTEMA DE FILA E MODAL =====

@api_view(['GET'])
@permission_classes([AllowAny])
def get_pending_report_for_guardian(request, guardian_id):
    """
    Endpoint para obter a pr√≥xima den√∫ncia pendente para um Guardi√£o
    """
    try:
        from django.utils import timezone
        from datetime import timedelta
        
        # Verificar se o Guardi√£o est√° online
        try:
            guardian = Guardian.objects.get(discord_id=guardian_id, status='online')
            print(f"‚úÖ Guardi√£o encontrado: {guardian.discord_display_name} (ID: {guardian.discord_id}, Status: {guardian.status})")
        except Guardian.DoesNotExist:
            # Verificar se o Guardi√£o existe mas est√° offline
            try:
                guardian_offline = Guardian.objects.get(discord_id=guardian_id)
                print(f"‚ùå Guardi√£o encontrado mas offline: {guardian_offline.discord_display_name} (ID: {guardian_offline.discord_id}, Status: {guardian_offline.status})")
                return Response({'error': f'Guardi√£o {guardian_offline.discord_display_name} est√° offline. Entre em servi√ßo primeiro.'}, status=status.HTTP_404_NOT_FOUND)
            except Guardian.DoesNotExist:
                print(f"‚ùå Guardi√£o com discord_id {guardian_id} n√£o encontrado no banco")
                
                # Criar Guardi√£o automaticamente se for um ID v√°lido
                print(f"‚ùå Guardi√£o com discord_id {guardian_id} n√£o encontrado - tentando criar automaticamente")
                
                # Verificar se √© um discord_id v√°lido (maior que 1000000000000000)
                if int(guardian_id) > 1000000000000000:
                    try:
                        # Criar Guardi√£o usando get_or_create para evitar duplica√ß√£o
                        guardian, created = Guardian.objects.get_or_create(
                            discord_id=guardian_id,
                            defaults={
                                'discord_username': f"User{guardian_id}",
                                'discord_display_name': f"Usu√°rio {guardian_id}",
                                'status': 'online',  # Criar como online por padr√£o
                                'level': 1,
                                'points': 0
                            }
                        )
                        
                        if created:
                            print(f"üÜï Guardi√£o criado automaticamente: {guardian.discord_display_name} (ID: {guardian.discord_id})")
                        else:
                            print(f"‚úÖ Guardi√£o encontrado ap√≥s cria√ß√£o: {guardian.discord_display_name} (ID: {guardian.discord_id})")
                    except Exception as e:
                        print(f"‚ùå Erro ao criar Guardi√£o: {e}")
                        return Response({'error': f'Erro ao criar Guardi√£o: {str(e)}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
                else:
                    return Response({'error': f'Guardi√£o com ID {guardian_id} n√£o encontrado'}, status=status.HTTP_404_NOT_FOUND)
        
        # Verificar se j√° est√° em uma sess√£o ativa SEM TER VOTADO
        active_session = SessionGuardian.objects.filter(
            guardian=guardian,
            is_active=True,
            has_voted=False
        ).first()
        
        if active_session:
            # Verificar se a sess√£o ainda est√° v√°lida (n√£o expirou)
            if active_session.session.voting_deadline and active_session.session.voting_deadline < timezone.now():
                # Sess√£o expirada - marcar como inativa e continuar
                active_session.is_active = False
                active_session.left_at = timezone.now()
                active_session.save()
                print(f"‚è∞ Sess√£o expirada para guardi√£o {guardian.discord_display_name}")
            else:
                # Retornar a sess√£o atual v√°lida
                session_data = {
                    'session_id': str(active_session.session.id),
                    'report_id': active_session.session.report.id,
                    'report': {
                        'id': active_session.session.report.id,
                        'reason': active_session.session.report.reason,
                        'reported_user_id': active_session.session.report.reported_user_id,
                        'reporter_user_id': active_session.session.report.reporter_user_id,
                        'created_at': active_session.session.report.created_at.isoformat(),
                    },
                    'messages': [],
                    'voting_deadline': active_session.session.voting_deadline.isoformat() if active_session.session.voting_deadline else None,
                    'time_remaining': None
                }
                
                # Calcular tempo restante
                if active_session.session.voting_deadline:
                    remaining = active_session.session.voting_deadline - timezone.now()
                    session_data['time_remaining'] = max(0, int(remaining.total_seconds()))
                
                # Buscar mensagens da den√∫ncia
                messages = Message.objects.filter(report=active_session.session.report).order_by('timestamp')
                session_data['messages'] = [
                    {
                        'id': msg.id,
                        'original_user_id': msg.original_user_id,
                        'anonymized_username': msg.anonymized_username,
                        'content': msg.content,
                        'timestamp': msg.timestamp.isoformat(),
                        'is_reported_user': msg.is_reported_user
                    }
                    for msg in messages
                ]
                
                return Response(session_data)
        
        # Buscar pr√≥xima den√∫ncia na fila que o guardi√£o ainda n√£o votou
        queue_items = ReportQueue.objects.filter(
            status__in=['pending', 'assigned']
        ).order_by('-priority', 'created_at')
        
        print(f"üîç Buscando den√∫ncia na fila para guardi√£o {guardian.discord_display_name}")
        print(f"üîç Total de itens na fila: {queue_items.count()}")
        
        queue_item = None
        for item in queue_items:
            # Verificar se o guardi√£o j√° votou nesta den√∫ncia
            has_voted = Vote.objects.filter(
                report=item.report,
                guardian=guardian
            ).exists()
            
            if not has_voted:
                queue_item = item
                print(f"‚úÖ Den√∫ncia encontrada: {item} (Guardi√£o ainda n√£o votou)")
                break
            else:
                print(f"‚è≠Ô∏è Pulando den√∫ncia {item.report.id} (Guardi√£o j√° votou)")
        
        if not queue_item:
            # Verificar se h√° den√∫ncias sem fila
            reports_without_queue = Report.objects.filter(
                status='pending'
            ).exclude(
                reportqueue__isnull=False
            ).order_by('-created_at')
            
            print(f"üîç Den√∫ncias sem fila: {reports_without_queue.count()}")
            
            if reports_without_queue.exists():
                # Criar fila para den√∫ncias √≥rf√£s
                for report in reports_without_queue:
                    ReportQueue.objects.get_or_create(
                        report=report,
                        defaults={'status': 'pending', 'priority': 0}
                    )
                    print(f"‚úÖ Fila criada para den√∫ncia #{report.id}")
                
                # Buscar novamente
                queue_item = ReportQueue.objects.filter(
                    status__in=['pending', 'assigned']
                ).order_by('-priority', 'created_at').first()
            
            if not queue_item:
                return Response({'message': 'Nenhuma den√∫ncia pendente na fila'})
        
        # Verificar se j√° existe sess√£o ativa para esta den√∫ncia
        existing_session = VotingSession.objects.filter(
            report=queue_item.report,
            status__in=['waiting', 'voting']
        ).first()
        
        if existing_session:
            # Verificar se o guardi√£o j√° votou nesta den√∫ncia
            existing_vote = Vote.objects.filter(
                report=queue_item.report,
                guardian=guardian
            ).exists()
            
            if existing_vote:
                return Response({
                    'error': 'Voc√™ j√° votou nesta den√∫ncia anteriormente',
                    'message': 'N√£o √© poss√≠vel participar novamente desta den√∫ncia'
                })
            
            # Adicionar guardi√£o √† sess√£o existente
            session_guardian, created = SessionGuardian.objects.get_or_create(
                session=existing_session,
                guardian=guardian,
                defaults={'is_active': True}
            )
            
            if not created:
                return Response({
                    'error': 'Voc√™ j√° est√° participando desta sess√£o',
                    'message': 'Aguarde sua vez de votar'
                })
            
            session = existing_session
        else:
            # Criar nova sess√£o de vota√ß√£o
            session = VotingSession.objects.create(
                report=queue_item.report,
                status='waiting',
                voting_deadline=timezone.now() + timedelta(minutes=5)
            )
            
            # Adicionar Guardi√£o √† sess√£o
            SessionGuardian.objects.create(
                session=session,
                guardian=guardian,
                is_active=True
            )
            
            # Atualizar status da fila
            queue_item.status = 'assigned'
            queue_item.assigned_at = timezone.now()
            queue_item.save()
            
            # Atualizar status da sess√£o
            session.status = 'voting'
            session.started_at = timezone.now()
            session.save()
        
        # Retornar dados da sess√£o
        session_data = {
            'session_id': str(session.id),
            'report_id': session.report.id,
            'report': {
                'id': session.report.id,
                'reason': session.report.reason,
                'reported_user_id': session.report.reported_user_id,
                'reporter_user_id': session.report.reporter_user_id,
                'created_at': session.report.created_at.isoformat(),
            },
            'messages': [],
            'voting_deadline': session.voting_deadline.isoformat(),
            'time_remaining': 300  # 5 minutos em segundos
        }
        
        # Buscar mensagens da den√∫ncia
        messages = Message.objects.filter(report=session.report).order_by('timestamp')
        print(f"üîç Mensagens encontradas para den√∫ncia {session.report.id}: {messages.count()}")
        
        session_data['messages'] = [
            {
                'id': msg.id,
                'original_user_id': msg.original_user_id,
                'anonymized_username': msg.anonymized_username,
                'content': msg.content,
                'timestamp': msg.timestamp.isoformat(),
                'is_reported_user': msg.is_reported_user
            }
            for msg in messages
        ]
        
        print(f"üîç Mensagens retornadas: {len(session_data['messages'])}")
        
        return Response(session_data)
        
    except Exception as e:
        return Response(
            {'error': f'Erro ao obter den√∫ncia pendente: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['GET'])
@permission_classes([AllowAny])
def get_guardian_status(request, guardian_id):
    """
    Endpoint para verificar o status de um Guardi√£o
    """
    try:
        print(f"üîç Verificando status do Guardi√£o ID: {guardian_id}")
        try:
            guardian = Guardian.objects.get(discord_id=guardian_id)
            print(f"‚úÖ Guardi√£o encontrado: {guardian.discord_display_name} (Status: {guardian.status})")
            return Response({
                'success': True,
                'guardian': {
                    'id': guardian.id,
                    'discord_id': guardian.discord_id,
                    'discord_display_name': guardian.discord_display_name,
                    'status': guardian.status,
                    'level': guardian.level,
                    'points': guardian.points
                },
                'is_online': guardian.status == 'online'
            })
        except Guardian.DoesNotExist:
            # Se for discord_id 1 (usu√°rio de teste), criar um Guardi√£o tempor√°rio
            if guardian_id == 1:
                print(f"üîß Criando Guardi√£o tempor√°rio para discord_id {guardian_id}")
                guardian = Guardian.objects.create(
                    discord_id=guardian_id,
                    discord_username="TestUser",
                    discord_display_name="Usu√°rio de Teste",
                    status='online',  # Criar como online por padr√£o
                    level=1,
                    points=0
                )
                return Response({
                    'success': True,
                    'guardian': {
                        'id': guardian.id,
                        'discord_id': guardian.discord_id,
                        'discord_display_name': guardian.discord_display_name,
                        'status': guardian.status,
                        'level': guardian.level,
                        'points': guardian.points
                    },
                    'is_online': guardian.status == 'online'
                })
            else:
                # Para discord_ids reais, criar automaticamente se for um ID v√°lido
                print(f"‚ùå Guardi√£o com discord_id {guardian_id} n√£o encontrado - tentando criar automaticamente")
                
                # Verificar se √© um discord_id v√°lido (maior que 1000000000000000)
                if int(guardian_id) > 1000000000000000:
                    try:
                        # Criar Guardi√£o usando get_or_create para evitar duplica√ß√£o
                        guardian, created = Guardian.objects.get_or_create(
                            discord_id=guardian_id,
                            defaults={
                                'discord_username': f"User{guardian_id}",
                                'discord_display_name': f"Usu√°rio {guardian_id}",
                                'status': 'online',  # Criar como online por padr√£o
                                'level': 1,
                                'points': 0
                            }
                        )
                        
                        if created:
                            print(f"üÜï Guardi√£o criado automaticamente: {guardian.discord_display_name} (ID: {guardian.discord_id})")
                        else:
                            print(f"‚úÖ Guardi√£o encontrado ap√≥s cria√ß√£o: {guardian.discord_display_name} (ID: {guardian.discord_id})")
                        
                        return Response({
                            'success': True,
                            'guardian': {
                                'id': guardian.id,
                                'discord_id': guardian.discord_id,
                                'discord_display_name': guardian.discord_display_name,
                                'status': guardian.status,
                                'level': guardian.level,
                                'points': guardian.points
                            },
                            'is_online': guardian.status == 'online',
                            'message': 'Guardi√£o criado automaticamente' if created else 'Guardi√£o encontrado'
                        })
                    except Exception as e:
                        print(f"‚ùå Erro ao criar Guardi√£o: {e}")
                        return Response({
                            'success': False,
                            'error': f'Erro ao criar perfil de Guardi√£o',
                            'message': 'Tente fazer login no site primeiro',
                            'discord_id': guardian_id
                        }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
                else:
                    return Response({
                        'success': False,
                        'error': f'Usu√°rio n√£o registrado como Guardi√£o',
                        'message': 'Para se tornar um Guardi√£o, fa√ßa login no site primeiro',
                        'discord_id': guardian_id
                    }, status=status.HTTP_404_NOT_FOUND)
            
    except Exception as e:
        return Response(
            {'error': f'Erro ao verificar status do Guardi√£o: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['POST'])
@permission_classes([AllowAny])
def cast_vote_in_session(request):
    """
    Endpoint para registrar voto em uma sess√£o de vota√ß√£o
    """
    try:
        from django.utils import timezone
        
        data = request.data
        
        # Validar dados
        required_fields = ['session_id', 'guardian_id', 'vote_type']
        for field in required_fields:
            if field not in data:
                return Response(
                    {'error': f'Campo obrigat√≥rio ausente: {field}'},
                    status=status.HTTP_400_BAD_REQUEST
                )
        
        # Verificar se o voto √© v√°lido
        if data['vote_type'] not in ['improcedente', 'intimidou', 'grave']:
            return Response(
                {'error': 'Tipo de voto inv√°lido'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Buscar sess√£o e Guardi√£o
        try:
            print(f"üîç cast_vote_in_session - Dados recebidos: {data}")
            print(f"üîç cast_vote_in_session - session_id: {data.get('session_id')}")
            print(f"üîç cast_vote_in_session - guardian_id: {data.get('guardian_id')}")
            print(f"üîç cast_vote_in_session - vote_type: {data.get('vote_type')}")
            
            session = VotingSession.objects.get(id=data['session_id'])
            guardian = Guardian.objects.get(discord_id=data['guardian_id'])
            session_guardian = SessionGuardian.objects.get(
                session=session,
                guardian=guardian,
                is_active=True
            )
        except (VotingSession.DoesNotExist, Guardian.DoesNotExist, SessionGuardian.DoesNotExist):
            return Response(
                {'error': 'Sess√£o ou Guardi√£o n√£o encontrado'},
                status=status.HTTP_404_NOT_FOUND
            )
        
        # Verificar se j√° votou
        if session_guardian.has_voted:
            return Response(
                {'error': 'Voc√™ j√° votou nesta sess√£o'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Verificar se a sess√£o expirou
        if session.is_expired():
            return Response(
                {'error': 'Tempo de vota√ß√£o expirado'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Registrar voto
        session_guardian.has_voted = True
        session_guardian.vote_type = data['vote_type']
        session_guardian.voted_at = timezone.now()
        session_guardian.save()
        
        # Criar voto permanente (sempre criar novo, n√£o usar get_or_create)
        vote, created = Vote.objects.get_or_create(
            report=session.report,
            guardian=guardian,
            defaults={'vote_type': data['vote_type']}
        )
        
        # Se j√° existe voto, n√£o permitir votar novamente
        if not created:
            return Response(
                {'error': 'Voc√™ j√° votou nesta den√∫ncia anteriormente'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Atualizar contadores da den√∫ncia
        report = session.report
        if data['vote_type'] == 'improcedente':
            report.votes_improcedente += 1
        elif data['vote_type'] == 'intimidou':
            report.votes_intimidou += 1
        elif data['vote_type'] == 'grave':
            report.votes_grave += 1
        
        report.total_votes += 1
        report.status = 'voting'
        report.save()
        
        # Verificar se todos os Guardi√µes ativos votaram
        active_guardians = session.get_active_guardians()
        voted_guardians = active_guardians.filter(has_voted=True)
        
        if voted_guardians.count() >= 5:
            # Concluir sess√£o
            session.status = 'completed'
            session.completed_at = timezone.now()
            session.save()
            
            # Concluir den√∫ncia
            report.status = 'completed'
            report.punishment = report.calculate_punishment()
            report.save()
            
            # Atualizar fila
            try:
                queue_item = ReportQueue.objects.get(report=report)
                queue_item.status = 'completed'
                queue_item.completed_at = timezone.now()
                queue_item.save()
            except ReportQueue.DoesNotExist:
                print(f"‚ö†Ô∏è Item da fila n√£o encontrado para den√∫ncia {report.id}")
            
            # Notificar bot para aplicar puni√ß√£o
            # notify_bot_apply_punishment(report) # Desabilitado por enquanto
        
        # Buscar votos an√¥nimos para mostrar
        anonymous_votes = []
        all_votes = Vote.objects.filter(report=session.report).order_by('created_at')
        for vote in all_votes:
            anonymous_votes.append({
                'vote_type': vote.vote_type,
                'vote_display': vote.get_vote_type_display(),
                'timestamp': vote.created_at.isoformat()
            })
        
        return Response({
            'success': True,
            'message': 'Voto registrado com sucesso',
            'vote_type': data['vote_type'],  # Adicionar vote_type na resposta
            'session_completed': session.status == 'completed',
            'votes_count': voted_guardians.count(),
            'total_active_guardians': active_guardians.count(),
            'anonymous_votes': anonymous_votes,
            'total_votes': all_votes.count()
        })
        
    except Exception as e:
        return Response(
            {'error': f'Erro ao registrar voto: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['POST'])
@permission_classes([AllowAny])
def leave_voting_session(request):
    """
    Endpoint para Guardi√£o sair de uma sess√£o de vota√ß√£o
    """
    try:
        from django.utils import timezone
        
        data = request.data
        
        # Validar dados
        if 'session_id' not in data or 'guardian_id' not in data:
            return Response(
                {'error': 'Campos obrigat√≥rios ausentes'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Buscar sess√£o e Guardi√£o
        try:
            print(f"üîç leave_voting_session - Dados recebidos: {data}")
            print(f"üîç leave_voting_session - session_id: {data.get('session_id')}")
            print(f"üîç leave_voting_session - guardian_id: {data.get('guardian_id')}")
            
            session = VotingSession.objects.get(id=data['session_id'])
            guardian = Guardian.objects.get(discord_id=data['guardian_id'])
            session_guardian = SessionGuardian.objects.get(
                session=session,
                guardian=guardian,
                is_active=True
            )
            print(f"üîç leave_voting_session - Sess√£o encontrada: {session.id}")
            print(f"üîç leave_voting_session - Guardi√£o encontrado: {guardian.discord_display_name}")
            print(f"üîç leave_voting_session - SessionGuardian encontrado: {session_guardian.id}")
        except (VotingSession.DoesNotExist, Guardian.DoesNotExist, SessionGuardian.DoesNotExist) as e:
            print(f"‚ùå leave_voting_session - Erro ao buscar: {e}")
            return Response(
                {'error': 'Sess√£o ou Guardi√£o n√£o encontrado'},
                status=status.HTTP_404_NOT_FOUND
            )
        
        # Marcar como inativo
        session_guardian.is_active = False
        session_guardian.left_at = timezone.now()
        session_guardian.save()
        
        # Se n√£o votou, cancelar o voto
        if not session_guardian.has_voted:
            # Remover da sess√£o
            session_guardian.delete()
            
            # Verificar se ainda h√° Guardi√µes ativos
            active_guardians = session.get_active_guardians()
            if active_guardians.count() == 0:
                # Cancelar sess√£o e recolocar na fila
                session.status = 'cancelled'
                session.save()
                
                queue_item = ReportQueue.objects.get(report=session.report)
                queue_item.status = 'pending'
                queue_item.assigned_at = None
                queue_item.save()
        
        return Response({
            'success': True,
            'message': 'Saiu da sess√£o com sucesso'
        })
        
    except Exception as e:
        return Response(
            {'error': f'Erro ao sair da sess√£o: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


